if (jsonMatch && jsonMatch[1]) {
  return jsonMatch[1].trim();
}

// Also try to find just a JSON object if no markdown but looks like JSON
const objectMatch = text.match(/(\{[\s\S]*\})/);
if (objectMatch && objectMatch[1]) {
  return objectMatch[1].trim();
}

return text.trim();
}

export const generateAndSendAiReply = action({
  args: {
    leadId: v.id("leads"),
    phoneNumber: v.string(),
    context: v.any(),
    prompt: v.string(),
    isAutoReply: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    console.log(`Generating AI reply for ${args.phoneNumber}...`);

    try {
      // 1. Get available products and ranges for context
      const products = await ctx.runQuery(api.products.listProducts);
      const ranges = await ctx.runQuery(api.whatsappQueries.listRangePdfs);

      const productList = products.map(p => p.name).join(", ");
      const rangeList = ranges.map(r => `${r.name} (Division: ${r.division || "General"})`).join(", ");

      // 2. Generate content using Gemini
      const aiResponse = await ctx.runAction(api.ai.generateContent, {
        prompt: args.prompt,
        type: "chat_reply",
        userId: (args.context as any).userId || args.leadId, // Fallback if no userId
        leadId: args.leadId,
        context: {
          ...args.context,
          availableProducts: productList,
          availableRanges: rangeList,
        }
      });

      // 3. Parse the response (handle JSON if present)
      const cleanedResponse = extractJsonFromMarkdown(aiResponse);

      let parsedResponse;
      try {
        // Try to parse as JSON if it looks like it
        if (cleanedResponse.trim().startsWith("{")) {
          parsedResponse = JSON.parse(cleanedResponse);
        }
      } catch (e) {
        console.log("Response is not valid JSON, treating as text");
      }

      // 4. Handle different response types
      if (parsedResponse) {
        // CASE A: Full Catalogue Request
        if (parsedResponse.fullCatalogue) {
          console.log("AI detected full catalogue request");

          // Send text first
          await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
            phoneNumber: args.phoneNumber,
            message: "Here is our complete product catalog. I'll send the PDFs now.",
            leadId: args.leadId,
          });

          // Send all PDFs
          const allRanges = await ctx.runQuery(api.whatsappQueries.listRangePdfs);

          // Send sequentially with delay to prevent OCC
          for (const range of allRanges) {
            try {
              await ctx.runAction(api.whatsapp.sendWhatsAppMedia, {
                phoneNumber: args.phoneNumber,
                leadId: args.leadId,
                storageId: range.storageId,
                fileName: `${range.name}.pdf`,
                mimeType: "application/pdf",
                message: range.name
              });
              // Small delay between sends
              await new Promise(resolve => setTimeout(resolve, 1000));
            } catch (err) {
              console.error(`Failed to send PDF ${range.name}:`, err);
            }
          }
          return;
        }

        // CASE B: Specific Range Request
        if (parsedResponse.rangeName) {
          console.log(`AI detected range request: ${parsedResponse.rangeName}`);

          const range = await ctx.runQuery(api.whatsappQueries.getRangePdfByName, { 
            name: parsedResponse.rangeName 
          });

          if (range) {
            await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
              phoneNumber: args.phoneNumber,
              message: `Here is the ${parsedResponse.rangeName} you requested.`,
              leadId: args.leadId,
            });

            await ctx.runAction(api.whatsapp.sendWhatsAppMedia, {
              phoneNumber: args.phoneNumber,
              leadId: args.leadId,
              storageId: range.storageId,
              fileName: `${range.name}.pdf`,
              mimeType: "application/pdf",
            });
            return;
          }
        }

        // CASE C: Product Images Request
        if (parsedResponse.productNames && Array.isArray(parsedResponse.productNames)) {
          console.log(`AI detected product image request: ${parsedResponse.productNames.join(", ")}`);

          let foundAny = false;

          // Send initial message
          await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
            phoneNumber: args.phoneNumber,
            message: `I'll check for images of: ${parsedResponse.productNames.join(", ")}`,
            leadId: args.leadId,
          });

          for (const productName of parsedResponse.productNames) {
            // Search for product (fuzzy match handled by query or exact match)
            // For now using exact match or simple find from list
            const product = products.find(p => 
              p.name.toLowerCase().includes(productName.toLowerCase()) || 
              productName.toLowerCase().includes(p.name.toLowerCase())
            );

            if (product && product.images && product.images.length > 0) {
              foundAny = true;

              // Send ALL images for the product sequentially
              console.log(`Sending ${product.images.length} images for ${product.name}`);

              for (let i = 0; i < product.images.length; i++) {
                const imageId = product.images[i];
                try {
                  await ctx.runAction(api.whatsapp.sendWhatsAppMedia, {
                    phoneNumber: args.phoneNumber,
                    leadId: args.leadId,
                    storageId: imageId,
                    fileName: `${product.name.replace(/\s+/g, '_')}_${i+1}.jpg`,
                    mimeType: "image/jpeg", // Assuming JPEG, storage metadata would be better
                    message: i === 0 ? `Here are the images for ${product.name}` : undefined
                  });

                  // Add delay between images to prevent OCC errors
                  await new Promise(resolve => setTimeout(resolve, 1000));

                } catch (err) {
                  console.error(`Failed to send image ${i+1} for ${product.name}:`, err);
                }
              }
            }
          }

          if (!foundAny) {
            await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
              phoneNumber: args.phoneNumber,
              message: "I couldn't find images for those specific products in our database. Would you like to see our full catalog instead?",
              leadId: args.leadId,
            });
          }
          return;
        }
      }

      // CASE D: Standard Text Reply (or fallback)
      // If it was JSON but not one of the special cases, or just plain text
      const textToSend = typeof parsedResponse === 'object' ? JSON.stringify(parsedResponse) : cleanedResponse;

      await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
        phoneNumber: args.phoneNumber,
        message: textToSend,
        leadId: args.leadId,
      });

    } catch (error) {
      console.error("Error in generateAndSendAiReply:", error);
      // Fallback error message
      await ctx.runAction(api.whatsapp.sendWhatsAppMessage, {
        phoneNumber: args.phoneNumber,
        message: "I apologize, but I'm having trouble processing your request right now. A human agent will be with you shortly.",
        leadId: args.leadId,
      });
    }
  }
});